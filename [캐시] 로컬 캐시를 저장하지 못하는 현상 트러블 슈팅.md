### ë¬¸ì œ ìƒí™©

**MapService.java**

```java
@Service
@RequiredArgsConstructor
public class MapService {

    private final MapPolygonRepository mapPolygonRepository;

    @Transactional(readOnly = true)
    @Cacheable(cacheManager = "caffeineCacheManager", cacheNames = "polygon")
    public MapPolygon findMapPolygonByMainAddress(final MainAddressResponse mainAddressResponse) {
        return mapPolygonRepository.findByAddressDepth1AndAddressDepth2(
                mainAddressResponse.getAddressDepth1(),
                mainAddressResponse.getAddressDepth2()
        );
    }
}
```

ìœ„ì™€ ê°™ì´ ì½”ë“œë¥¼ ì‘ì„±í–ˆì„ ë•Œ ë™ì¼í•œ mainAddressResponse ê°’ìœ¼ë¡œ ë³´ë‚´ë„ ìºì‹œì—ì„œ ì¡°íšŒë˜ì§€ì•Šê³  DBì— ì¿¼ë¦¬ê°€ ë‚˜ê°€ëŠ” í˜„ìƒì´ ì§€ì†ë˜ì—ˆìŠµë‹ˆë‹¤.

### ë¬¸ì œ ì›ì¸

**MapService.java**

```java
@Transactional(readOnly = true)
    @Cacheable(cacheManager = "caffeineCacheManager", cacheNames = "polygon")
    public MapPolygon findMapPolygonByMainAddress(final MainAddressResponse mainAddressResponse) {
				// Local Cache ì•ˆì— ë‚´ìš© í™•ì¸í•´ë³´ê¸°
				Cache cache = cacheManager.getCache("polygon");
        com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = (com.github.benmanes.caffeine.cache.Cache<Object, Object>)cache.getNativeCache();

        // ìºì‹œì˜ ëª¨ë“  í•­ëª©ì„ ì¡°íšŒ
        Map<Object, Object> cacheMap = nativeCache.asMap();

        // ìºì‹œì˜ í‚¤ì™€ ê°’ ì¶œë ¥
        for (Map.Entry<Object, Object> entry : cacheMap.entrySet()) {
            Object key = entry.getKey();
            Object value = entry.getValue();
            System.out.println("í‚¤: " + key + ", ê°’: " + value);
        }
				// 

        return mapPolygonRepository.findByAddressDepth1AndAddressDepth2(
                mainAddressResponse.getAddressDepth1(),
                mainAddressResponse.getAddressDepth2()
        );
    }
```

ì™œ ì•ˆë ê¹Œë¼ëŠ” ìƒê°ì— ë¡œì»¬ ìºì‹œì•ˆì— ì •ìƒì ìœ¼ë¡œ ì €ì¥ë˜ëŠ”ì§€ í™•ì¸í•´ë³´ê³  ì‹¶ì—ˆìŠµë‹ˆë‹¤. ìœ„ì™€ ê°™ì´ Local Cache ì•ˆì— ì €ì¥ë˜ëŠ” ìºì‹œì˜ ëª©ë¡ì„ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì•˜ìŠµë‹ˆë‹¤. APIë¥¼ 3ë²ˆ ìš”ì²­í•´ë³´ì•˜ëŠ”ë° ë§ˆì§€ë§‰ 3ë²ˆì§¸ ìš”ì²­ì— 2ê°œì˜ ìºì‹œê°€ ì €ì¥ëœ ê²ƒì„ í™•ì¸í•´ë³¼ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

![Untitled](./image/cache_local_cache_store.png)

ì €ëŠ” ë¶„ëª… ë™ì¼í•œ ë°ì´í„°ë¥¼ ë„˜ê²¨ë°›ì•„ì„œ ì €ì¥í•œ ê²ƒì¸ë° ì™œ ìºì‹œì— ì—†ë‹¤ê³  íŒë‹¨í•˜ì—¬ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ ë§¤ë²ˆ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ ì €ì¥í•˜ëŠ” ê²ƒì¼ê¹Œìš”?

ì €ëŠ” ê·¸ ì´ìœ ë¥¼ ìŠ¤í”„ë§ ê³µì‹ ë¬¸ì„œì—ì„œ ì°¾ì„ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

[Declarative Annotation-based Caching :: Spring Framework](https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotations-cacheable-default-key)

> **Default Key Generation - Spring Cache Abstraction**
> 
> 
> Since caches are essentially key-value stores, each invocation of a cached method needs to be translated into a suitable key for cache access. The caching abstraction uses a simpleÂ `KeyGenerator`Â based on the following algorithm:
> 
> - If no parameters are given, returnÂ `SimpleKey.EMPTY`.
> - If only one parameter is given, return that instance.
> - If more than one parameter is given, return aÂ `SimpleKey`Â that contains all parameters.
> 
> This approach works well for most use-cases, as long as parameters have natural keys and implement validÂ `hashCode()`Â andÂ `equals()`Â methods. If that is not the case, you need to change the strategy.
> 
> To provide a different default key generator, you need to implement theÂ `org.springframework.cache.interceptor.KeyGenerator`Â interface.
> 

ìœ„ ë‚´ìš©ì€ Spring Cacheì˜ ê¸°ë³¸ í‚¤ ìƒì„± ì „ëµì¸ë°ìš”. ìºì‹±ì„ í•  ë•Œ Keyë¥¼ ëª…ì‹œí•˜ì§€ ì•ŠëŠ” ê²½ìš° ë§¤ê°œë³€ìˆ˜ì˜ hashCodeë¥¼ ì´ìš©í•´ì„œ Keyë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì´ì£ ! ê·¸ëŸ¼ ì € MainAddressResponseëŠ” ê°ì²´ì´ê³  ë‚´ë¶€ì— ìˆëŠ” ê°’ì´ ë§¤ë²ˆ ê°™ë”ë¼ë„ ìƒì„±ë  ë•Œë§ˆë‹¤ ë‹¤ë¥¸ HashCodeë¥¼ ê°–ê¸° ë•Œë¬¸ì— ê°ì²´ ì•ˆì˜ ê°’ì´ ê°™ë”ë¼ë„ ë‹¤ë¥¸ Keyë¡œ ì¸ì‹í•´ì„œ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í•œ ê²ƒì´ì—ˆìŠµë‹ˆë‹¤!

### í•´ê²° ë°©ë²•

í•´ê²° ë°©ë²•ì—ëŠ” ì—¬ëŸ¬ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í•´ë‹¹ ê°ì²´ì—ì„œ hashCodeë¥¼ Overrideí•´ì„œ ê°’ì´ ë™ì¼í•  ë•ŒëŠ” ë™ì¼í•œ hashCodeë¥¼ ê°–ê²Œ í•´ì£¼ëŠ” ë°©ë²•, ì•„ë‹ˆë©´ ì§ì ‘ keyë¥¼ ì§€ì •í•´ì£¼ëŠ” ë°©ë²•, ì•„ë‹ˆë©´ Key ìƒì„± ì „ëµì„ ì§ì ‘ ë§Œë“¤ì–´ì„œ í•´ë‹¹ Key ìƒì„± ì „ëµ ë“± ë‹¤ì–‘í•œ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.

```java
@Service
@RequiredArgsConstructor
public class MapService {

    private final MapPolygonRepository mapPolygonRepository;

    @Transactional(readOnly = true)
    @Cacheable(cacheManager = "caffeineCacheManager", cacheNames = "polygon", key = "#mainAddressResponse.addressDepth2.name")
    public MapPolygon findMapPolygonByMainAddress(final MainAddressResponse mainAddressResponse) {
        return mapPolygonRepository.findByAddressDepth1AndAddressDepth2(
                mainAddressResponse.getAddressDepth1(),
                mainAddressResponse.getAddressDepth2()
        );
    }
}
```

ìœ„ ì½”ë“œì—ì„œëŠ” í•´ë‹¹ APIë¥¼ ìš”ì²­í•  ë•Œ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°›ëŠ” ê°’ì´ ê³ ìœ í•œ ê°’ì´ê¸° ë•Œë¬¸ì— addressDepth2ì˜ nameì„ í‚¤ë¡œ ì§€ì •í•˜ì—¬ ë™ì¼í•œ nameì´ ë“¤ì–´ì˜¬ ê²½ìš° ìºì‹±ëœ ë°ì´í„°ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆë„ë¡ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.

ìºì‹œì— ëŒ€í•´ì„œ ì œëŒ€ë¡œ ì•Œì§€ë„ ëª»í•˜ëŠ”ë° ë¹¨ë¦¬ êµ¬í˜„í•˜ë ¤ëŠ” ìš•ì‹¬ì— ì˜¤ëœì‹œê°„ë™ì•ˆ íŠ¸ëŸ¬ë¸” ìŠˆíŒ…í–ˆì—ˆë˜ ê²ƒ ê°™ìŠµë‹ˆë‹¤. ì–´ë– í•œ ê¸°ìˆ ì„ ì‚¬ìš©í•˜ê¸° ì „ì—ëŠ” ê¼­ ê·¸ ê¸°ìˆ ì— ëŒ€í•´ì„œ ë¨¼ì € ê³µë¶€í•´ë³´ê³  ì ìš©í•˜ê¸°!! ğŸ‘ğŸ‘